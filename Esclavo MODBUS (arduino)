//ULTRASONIDO
#define TRIGGER 6
#define ECHO 7

#define UltraAdress 3

//joystick ANALOGICO
#define EjeX 0
#define EjeY 1
#define CLICK 11

#define EjeXAdress 0
#define EjeYAdress 1
#define ClickAdress 3

//pulsador
#define PULSE 4

//BallInterruptor
#define Interruptor 12
#define InterruptorAdress 5

//LEDRGB
#define BLUE 8
#define GREEN 9
#define RED 10

#define BLUE_ADRESS 2
#define GREEN_ADRESS 1
#define RED_ADRESS 0

const int MaxAdress = 20;

const int EnTxPin2 =  2;  // HIGH:TX y LOW:RX

const unsigned char INICIO = 0x3A; //Inicio de la trama
const unsigned char miDireccionH = 0x00; //Direccion del esclavo
const unsigned char miDireccionL = 0x04;
const unsigned char Fin1 = 0x0D; //Final1 de la trama
const unsigned char Fin2 = 0x0A; //Final2 de la trama

unsigned char Direccion_SlaveH = 0x00;
unsigned char Direccion_SlaveL = 0x00;
unsigned char InstruccionH = 0x00;
unsigned char InstruccionL = 0x00;
unsigned char Starting_Address_Hi = 0x00;
unsigned char Starting_Address_Lo = 0x00;
unsigned char Quantity_of_CR_Hi = 0x00;
unsigned char Quantity_of_CR_Lo = 0x00;
unsigned char ByteCount = 0x00;
unsigned char LRC16H = 0x00;
unsigned char LRC16L = 0x00;
uint16_t LRC = 0x00; //ENTERO SIN SIGNO 16 BITS

unsigned char CodigoError = 0x00;
unsigned char Dato1 = 0x00;
unsigned char Dato2 = 0x00;
uint16_t Adress = 0x0000;

bool COILOut[MaxAdress];
bool COILIn[MaxAdress];
unsigned char RegistersOUT[MaxAdress];
unsigned char RegistersIN[MaxAdress];

unsigned char RegistersTEMP[MaxAdress];
bool CoilsTEMP[MaxAdress];

int pos0 = 0;
int pos1 = 0;
int pos2 = 0;
int restantes = 0;


unsigned char inChar;
unsigned char outChar;


unsigned char BytesRespuesta = 0x00;

enum EstadosLectura
{
  InicioLeerTrama,
  ComprobarDireccionH,
  ComprobarDireccionL,
  LeerOrdenH,
  LeerOrdenL,
  LeerDireccionMemH,
  LeerDireccionMemL,
  LeerQuantity_of_CR_Hi,
  LeerQuantity_of_CR_Lo,
  LeerByteCount,
  LeerCampoDATOS,
  LeerDato1,
  LeerDato2,
  LeerLRC16H,
  LeerLRC16L,
  FinLeerTrama1,
  FinLeerTrama2
};

enum EstadosEnvio
{
  EnviarInicio,
  EnviarDireccionH,
  EnviarDireccionL,
  EnviarOrdenH,
  EnviarOrdenL,
  EnviarDato1,
  EnviarDato2,
  EnviarByteCount,
  EnviarDireccionMemH,
  EnviarDireccionMemL,
  EnviarQuantity_of_CR_Hi,
  EnviarQuantity_of_CR_Lo,
  EnviarDATOS,
  EnviarLRCH,
  EnviarLRCL,
  EnviarFin1,
  EnviarFin2
};


EstadosLectura EstadoLecturaActual;
EstadosEnvio EstadoEnvioActual;

void setup() 
{
  Serial.begin(9600);  
  Serial.setTimeout(100);  //establecemos un tiempo de espera de 100ms
  
  pinMode(EnTxPin2, OUTPUT);
  digitalWrite(EnTxPin2, LOW); //RS485 como receptor

  //ultrasonido
  pinMode(ECHO, INPUT);
  pinMode(TRIGGER, OUTPUT);
  digitalWrite(TRIGGER, LOW);

  //LED
  pinMode(RED, OUTPUT);
  pinMode(GREEN, OUTPUT);
  pinMode(BLUE, OUTPUT);

  analogWrite(RED, RegistersOUT[RED_ADRESS]);
  analogWrite(GREEN, RegistersOUT[GREEN_ADRESS]);
  analogWrite(BLUE, RegistersOUT[BLUE_ADRESS]);

  //BALL INTERRUPTOR
  pinMode (Interruptor, INPUT);

  //JOYSTICK
  pinMode (CLICK, INPUT);

  //

  EstadoLecturaActual=InicioLeerTrama;
  EstadoEnvioActual =EnviarInicio;
   
} 



//Con Loop podremos ver el mensaje completo
void loop() 
{ 
  ActualizarRegistersIn();
  ActualizarCoilsIn();

  ActualizarColorLED();
  /*
  for (int i = 0; i<MaxAdress;i++)
    {
      Serial.print(COILIn[i]);
    }
    Serial.println();
    delay(1500);


  for (int i = 0; i<MaxAdress;i++)
    {
      Serial.print(COILOut[i]);
    }
    Serial.println();
    

  for (int i = 0; i<MaxAdress;i++)
    {
      Serial.print(RegistersOUT[i]);
      Serial.print(" ");
    }
    Serial.println();
    for (int i = 0; i<MaxAdress;i++)
    {
      Serial.print(RegistersTEMP[i]);
      Serial.print(" ");
    }
    Serial.println();
    Serial.println();
    Serial.println();
    delay(650);

  for (int i = 0; i<MaxAdress;i++)
    {
      Serial.print(RegistersIN[i]);
      Serial.print(" ");
    }
    Serial.println();
    delay(650);
*/
  
}

void FInicioLeerTrama()
{
  LRC = 0x0000;
  if(inChar == INICIO) //Inicio de trama correcto
  {    
    EstadoLecturaActual = ComprobarDireccionH;
  }
}

void FComprobarDireccionH()
{
  if(inChar == miDireccionH)
  { 
    LRC = LRC + inChar;
    
    EstadoLecturaActual = ComprobarDireccionL;
  }
  else 
  {
    EstadoLecturaActual = InicioLeerTrama;
  }
}

void FComprobarDireccionL()
{
  if(inChar == miDireccionL)//Si el mensaje es para mi
  {
    LRC = LRC + inChar;
    EstadoLecturaActual = LeerOrdenH;
  }
  else 
  {
    EstadoLecturaActual = InicioLeerTrama;
  }
}


void FLeerOrdenH()
{
  LRC = LRC + inChar;
  InstruccionH = inChar;
  EstadoLecturaActual = LeerOrdenL;
}


void FLeerOrdenL()
{ 
  LRC = LRC + inChar;
  InstruccionL = inChar;
  EstadoLecturaActual = LeerDireccionMemH;

}

void FLeerDireccionMemH()
{
  LRC = LRC + inChar;
  Starting_Address_Hi = inChar;
  EstadoLecturaActual = LeerDireccionMemL;
}

void FLeerDireccionMemL()
{
  LRC = LRC + inChar;
  Starting_Address_Lo = inChar;
  if(InstruccionL == 0x05 or InstruccionL == 0x06) //el siguiente campo es un dato
  {
    EstadoLecturaActual = LeerDato1;
  }
  else 
  {
    EstadoLecturaActual = LeerQuantity_of_CR_Hi;
  }
}

void FLeerDato1()
{
  LRC = LRC + inChar;
  Dato1 = inChar;
  EstadoLecturaActual = LeerDato2;
}

void FLeerDato2()
{
  LRC = LRC + inChar;
  Dato2 = inChar;
  EstadoLecturaActual = LeerLRC16H;
}

void FLeerCampoDatos()
{
    LRC = LRC + inChar;
    RegistersTEMP[pos0]=inChar;
    pos0 ++;
    if(pos0 == ByteCount)
    {
      EstadoLecturaActual = LeerLRC16H;
      pos0 = 0;
    }
    
}

void FLeerQuantity_of_CR_Hi()
{
  LRC = LRC + inChar;
  Quantity_of_CR_Hi = inChar;
  EstadoLecturaActual = LeerQuantity_of_CR_Lo;
}

void FLeerQuantity_of_CR_Lo()
{
  LRC = LRC + inChar;
  Quantity_of_CR_Lo = inChar;
  if(InstruccionL == 0x01 or InstruccionL == 0x02 or InstruccionL == 0x03 or InstruccionL == 0x04)
  {
    EstadoLecturaActual = LeerLRC16H;
  }
  else 
  {
    EstadoLecturaActual = LeerByteCount;
  }
  restantes = Quantity_of_CR_Lo;
}

void FLeerByteCount()
{
  LRC = LRC + inChar;
  ByteCount = inChar;
  EstadoLecturaActual = LeerCampoDATOS;
}

void FLeerLRC16H()
{
  LRC = LRC xor 0xFFFF;
  LRC = LRC + 1;
  
  LRC16H = LRC>>8 ;
  if(inChar == LRC16H)
  {
    EstadoLecturaActual = LeerLRC16L;
  }
  else 
  {
    EstadoLecturaActual = LeerLRC16L; //TEMPORAL
  }
}

void FLeerLRC16L()
{
  LRC16L = LRC;
  if(inChar = LRC16L)
  {
    EstadoLecturaActual = FinLeerTrama1;
  }
  else
  {
    EstadoLecturaActual = FinLeerTrama1; //TEMPORAL
  }
}

void FFinLeerTrama1()
{ 
  if(inChar == Fin1)
  {
    EstadoLecturaActual = FinLeerTrama2;
  }
  else
  {
    
  }
}
void FFinLeerTrama2()
{
  LRC = 0x0000;
  Adress = Starting_Address_Lo;
  if(inChar == Fin2)
  {
    switch(InstruccionL)
    {
      case 0x01: ReadDiscreteOutCoils(); break;
      case 0x02: ReadDiscreteInCoils(); break;
      case 0x03: ReadAnalogOutRegisters(); break;
      case 0x04: ReadAnalogInRegisters(); break;
      case 0x05: WriteDiscreteOutCoil(); break;
      case 0x06: WriteAnalogOutRegisters(); break;
      case 0x0f: WriteMultipleDiscreteOutCoils(); break;
      case 0x10: WriteSimpleAnalogOutRegisters(); break;
    }
    Envio();
    EstadoLecturaActual = InicioLeerTrama;
  }
  else 
  {
  }
}

void ReadDiscreteOutCoils() //INSTRUCCION 1 //COMPLETADA
{
  int j = 0;
  BytesRespuesta = 0x01;
  int error=0;
  
  for(int i = 0; i< Quantity_of_CR_Lo; i++)
  {
    if(j>1 and COILOut[Adress+i]!=0)
    {
      error = 1;
    }
    else
    {
      error = 0;
    }
    RegistersTEMP[BytesRespuesta-1] = RegistersTEMP[BytesRespuesta-1] + (pow(2,j)*COILOut[Adress+i])+ error;
    if(j%8 == 0 and j!=0)
    {
      BytesRespuesta = BytesRespuesta+1;
      j=0;
    }
    else 
    {
      j = j +1;
    }
  }
  BytesRespuesta = ((Quantity_of_CR_Lo-1)/8) + 1;  
}

void ReadDiscreteInCoils() //INSTRUCCION 2 //COMPLETADA
{
  int j = 0;
  BytesRespuesta = 0x01;
  int error=0;
  
  for(int i = 0; i < Quantity_of_CR_Lo; i++)
  {
    if(j>1 and COILIn[Adress+i]!=0)
    {
      error = 1;
    }
    else
    {
      error = 0;
    }
    RegistersTEMP[BytesRespuesta-1] = RegistersTEMP[BytesRespuesta-1] + (pow(2,j)*COILIn[Adress+i])+ error;
    if(j%8 == 0 and j!=0)
    {
      BytesRespuesta = BytesRespuesta+1;
      j=0;
    }
    else 
    {
      j = j +1;
    }
  }
  /*if(i = Quantity_of_CR_Lo - 1)
    {
      LRC = LRC xor 0xFFFF;
      LRC = LRC + 1;
    }*/

  BytesRespuesta = ((Quantity_of_CR_Lo-1)/8) + 1;
    
}

void ReadAnalogOutRegisters() //INSTRUCCION 3
{
  for(int i = 0; i < Quantity_of_CR_Lo; i++)
  {
    RegistersTEMP[i] = RegistersOUT[Adress + i];
  }
  BytesRespuesta = Quantity_of_CR_Lo;
}

void ReadAnalogInRegisters()  //INSTRUCCION 4
{
  for(int i = 0; i < Quantity_of_CR_Lo; i++)
  {
    RegistersTEMP[i] = RegistersIN[Adress + i];
    BytesRespuesta = BytesRespuesta+1;
  }
}

void WriteDiscreteOutCoil()   //INSTRUCCION 5     //LA RESPUESTA A ESTE MENSAJE ES UN ECHO CON EL MISMO CONTENIDO QUE LE LLEGO AL ESCLAVO
{
  if(Dato1 == 0x00 and Dato2 == 0xFF)
  {
    COILOut[Adress] = true;
  }
  else if(Dato1 == 0xFF and Dato2 == 0x00)
  {
    COILOut[Adress] = false;
  }
}

void WriteAnalogOutRegisters()  //INSTRUCCION 6  //LA RESPUESTA A ESTE MENSAJE ES UN ECHO CON EL MISMO CONTENIDO QUE LE LLEGO AL ESCLAVO
{
  RegistersOUT[Adress] = Dato2;
}

void WriteMultipleDiscreteOutCoils()  //INSTRUCCION 0F
{
  int j = 0;
  int ByteCounter = 0;
  //no se por que entra solamente la segunda vez que lo mando
    for(int i = 0; i< Quantity_of_CR_Lo; i++)
    {
      COILOut[Adress + i] = (RegistersTEMP[ByteCounter] >> j) & 1;
      if(j%7 == 0 and j!=0)
      {
        
        ByteCounter = ByteCounter+1;
        j=0;
      }
      else 
      {
        j = j +1;
      }
    }
}



void WriteSimpleAnalogOutRegisters()  //INSTRUCCION 10
{
  for(int i = 0; i < ByteCount; i++)
  {
    RegistersOUT[Adress + i] = RegistersTEMP[i];
  }
}


void ActualizarColorLED()
{
  analogWrite(BLUE, RegistersOUT[BLUE_ADRESS]);
  analogWrite(GREEN, RegistersOUT[GREEN_ADRESS] );
  analogWrite(RED, RegistersOUT[RED_ADRESS]);
}
void ActualizarRegistersIn()
{
  RegistersIN[EjeXAdress] = ValorEje(EjeX);
  RegistersIN[EjeYAdress] = ValorEje(EjeY);
  RegistersIN[UltraAdress] = DistanciaUltrasonido();
}

void ActualizarCoilsIn()
{
  COILIn[InterruptorAdress] = digitalRead(Interruptor); 
  COILIn[ClickAdress] = digitalRead(CLICK);
}

unsigned char DistanciaUltrasonido()
{
  long duration;
  unsigned char distance;
  digitalWrite(TRIGGER, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIGGER, LOW);
  duration = pulseIn(ECHO,HIGH);
  distance = duration / 2 / 7.6;
  return distance;
}

int ValorEje(int EJE)
{
  int value = analogRead(EJE)/4;
  return value;
}





//Con esta funcion podemos comprobar cada 8bits
void serialEvent()
{
  //while(Serial.available())
  //{
    inChar = (unsigned char)Serial.read();
    
    switch(EstadoLecturaActual)
    {
      case EstadosLectura::InicioLeerTrama :
                  //Serial.print((int)inChar);
                  FInicioLeerTrama();
            break;
      case EstadosLectura::ComprobarDireccionH : 
                  //Serial.print((int)inChar);
                  FComprobarDireccionH();
            break;
      case EstadosLectura::ComprobarDireccionL : 
                  //Serial.print((int)inChar);
                  FComprobarDireccionL();
            break;
      case EstadosLectura::LeerOrdenH : 
                  //Serial.print((int)inChar);
                  FLeerOrdenH();
            break;     
      case EstadosLectura::LeerOrdenL : 
                  //Serial.print((int)inChar);
                  FLeerOrdenL();
            break;
      case EstadosLectura::LeerDireccionMemH :
                  //Serial.write(inChar);
                  FLeerDireccionMemH();
            break;
      case EstadosLectura::LeerDireccionMemL :
                  //Serial.write(inChar);
                  FLeerDireccionMemL();
            break;  
      case EstadosLectura::LeerQuantity_of_CR_Hi :
                  //Serial.write(inChar);
                  FLeerQuantity_of_CR_Hi();
            break;
      case EstadosLectura::LeerQuantity_of_CR_Lo :
                  //Serial.write(inChar);
                  FLeerQuantity_of_CR_Lo();
            break;
      case EstadosLectura::LeerByteCount :
                  //Serial.write(inChar);
                  FLeerByteCount();
            break;
      case EstadosLectura::LeerCampoDATOS :
                  //Serial.write(inChar);
                  FLeerCampoDatos();
            break;
      case EstadosLectura::LeerDato1 :
                  //Serial.write(inChar);
                  FLeerDato1();
            break;
      case EstadosLectura::LeerDato2 :
                  //Serial.write(inChar);
                  FLeerDato2();
            break;
      case EstadosLectura::LeerLRC16H :
                  //Serial.write(inChar);
                  FLeerLRC16H();
            break;
      case EstadosLectura::LeerLRC16L :
                  //Serial.write(inChar);
                  FLeerLRC16L();
            break;
      case EstadosLectura::FinLeerTrama1 :
                  //Serial.write(inChar);
                  FFinLeerTrama1();
            break;
      case EstadosLectura::FinLeerTrama2 :
                  //Serial.write(inChar);
                  FFinLeerTrama2();
            break;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
////////////// FUNCIONES DE RESPUESTA////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////



void Envio()
{
  bool FIN_ENVIO = false;
  do
  {
    digitalWrite(EnTxPin2, HIGH);
    delay(1);
    switch (EstadoEnvioActual)
    {
      case EstadosEnvio::EnviarInicio : //0
                  FEnviarInicio();
           break;
      case EstadosEnvio::EnviarDireccionH : //1
                  FEnviarDireccionH();
           break;
      case EstadosEnvio::EnviarDireccionL : //2
                  FEnviarDireccionL();
           break;
      case EstadosEnvio::EnviarOrdenH : //3
                  FEnviarOrdenH();
           break;
      case EstadosEnvio::EnviarOrdenL : //4
                  FEnviarOrdenL();
           break;
      case EstadosEnvio::EnviarByteCount :
                  FEnviarByteCount();
           break;
      case EstadosEnvio::EnviarDATOS :
                  FEnviarDatos();
           break;
      case EstadosEnvio::EnviarDireccionMemH : //5
                  FEnviarDireccionMemH();
           break;
      case EstadosEnvio::EnviarDireccionMemL : //6
                  FEnviarDireccionMemL();
           break;
      case EstadosEnvio::EnviarQuantity_of_CR_Hi : 
                  FEnviarQuantity_of_CR_Hi();
           break;
      case EstadosEnvio::EnviarQuantity_of_CR_Lo :
                  FEnviarQuantity_of_CR_Lo();
           break;
      case EstadosEnvio::EnviarDato1 :    //11
                  FEnviarDato1();
           break;
      case EstadosEnvio::EnviarDato2 :  //12
                  FEnviarDato2();
           break;
      case EstadosEnvio::EnviarLRCH : //13
                  FEnviarLRCH();
           break;
      case EstadosEnvio::EnviarLRCL : //14
                  FEnviarLRCL();
           break;
      case EstadosEnvio::EnviarFin1 : //15
                  FEnviarFIN1();
           break;
      case EstadosEnvio::EnviarFin2 : //16
                  FEnviarFIN2();
                  delay(1);
                  FEnviarFIN2();
                  FIN_ENVIO = true;
           break;
    }
  }while(FIN_ENVIO != true);
  digitalWrite(EnTxPin2, LOW);
}


void FEnviarInicio()
{
  
  Serial.write(INICIO);
  //Serial.write(0x52);
  EstadoEnvioActual = EnviarDireccionH;
  LRC16H = 0x00;
  LRC16L = 0x00;
  LRC = 0x00;
}
void FEnviarDireccionH()
{
  Serial.write(miDireccionH);
  LRC = LRC + miDireccionH;
  EstadoEnvioActual = EnviarDireccionL;
}
void FEnviarDireccionL()
{
  Serial.write(miDireccionL);
  LRC = LRC + miDireccionL;
  EstadoEnvioActual = EnviarOrdenH;
}
void FEnviarOrdenH()
{
  Serial.write(InstruccionH);
  LRC = LRC + InstruccionH;
  EstadoEnvioActual = EnviarOrdenL;
}
void FEnviarOrdenL()
{
  Serial.write(InstruccionL);
  LRC = LRC + InstruccionL;
  if(InstruccionL == 0x01 || InstruccionL == 0x02 || InstruccionL == 0x03 || InstruccionL == 0x04)
  {
    EstadoEnvioActual = EnviarByteCount;
  }
  else
  {
    EstadoEnvioActual = EnviarDireccionMemH;
  }
}

void FEnviarByteCount()
{
  Serial.write(BytesRespuesta);
  LRC = LRC + BytesRespuesta;
  EstadoEnvioActual = EnviarDATOS;
}

void FEnviarDireccionMemH()
{
  //Serial.write("ESTOY EN DIRECCION MEM H");
  Serial.write(Starting_Address_Hi);
  LRC = LRC + Starting_Address_Hi;
  EstadoEnvioActual = EnviarDireccionMemL;
}
void FEnviarDireccionMemL()
{
  Serial.write(Starting_Address_Lo);
  LRC = LRC + Starting_Address_Lo;
  if(InstruccionL == 0x05 || InstruccionL == 0x06)
  {
    EstadoEnvioActual = EnviarDato1;
  }
  else
  {
    EstadoEnvioActual = EnviarQuantity_of_CR_Hi;
  }
}

void FEnviarQuantity_of_CR_Hi()
{
  Serial.write(Quantity_of_CR_Hi);
  LRC = LRC + Quantity_of_CR_Hi;
  EstadoEnvioActual = EnviarQuantity_of_CR_Lo;
}


void FEnviarQuantity_of_CR_Lo()
{
  Serial.write(Quantity_of_CR_Lo);
  LRC = LRC + Quantity_of_CR_Lo;
  EstadoEnvioActual = EnviarLRCH;
}

void FEnviarDato1()
{
  Serial.write(Dato1);
  LRC = LRC + Dato1;
  EstadoEnvioActual = EnviarDato2;
}
void FEnviarDato2()
{
  Serial.write(Dato2);
  LRC = LRC + Dato2;
  if(InstruccionL == 0x05 || InstruccionL == 0x06)
  {
    EstadoEnvioActual = EnviarLRCH;
  }
}

void FEnviarDatos()
{
  for(int i = 0; i < BytesRespuesta; i++)
  {
      Serial.write(RegistersTEMP[i]);
      LRC = LRC + RegistersTEMP[i];
  }
  
  EstadoEnvioActual = EnviarLRCH;
  
}

void FEnviarLRCH()
{
  LRC = LRC xor 0xFFFF;
  LRC = LRC + 1;
  LRC16H = LRC>>8 ;
  Serial.write(LRC16H);
  EstadoEnvioActual = EnviarLRCL;
}
void FEnviarLRCL()
{
  LRC16L = LRC;
  Serial.write(LRC16L);
  EstadoEnvioActual = EnviarFin1;
}
void FEnviarFIN1()
{
  Serial.write(Fin1);
  EstadoEnvioActual = EnviarFin2;
}
void FEnviarFIN2()
{
  Serial.write(Fin2);
  BytesRespuesta = 0x00;
  for(int i = 0 ; i < MaxAdress ; i++)
  {
    RegistersTEMP[i] = 0x00;
  }
  EstadoEnvioActual = EnviarInicio;
}
