library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity Master_MOD is
    Port ( clk : in STD_LOGIC;
           reset : in STD_LOGIC;
           SEND : in STD_LOGIC;
           Switch0 : in STD_LOGIC;
           SwitchB : in STD_LOGIC;
           SwitchG : in STD_LOGIC;
           SwitchR : in STD_LOGIC;
           tx: out STD_LOGIC;
           DERE2 : out STD_LOGIC);
end Master_MOD;

architecture Behavioral of Master_MOD is
        
    
component DivisorReloj is
Port ( clk : in STD_LOGIC;
       reset : in STD_LOGIC;
       clk_div : out STD_LOGIC);
end component;
  
  signal color : std_logic_vector (0 to 2);
  signal COLORInt : integer range 0 to 7;

  signal SignalValor : std_logic;

  signal clk_div : std_logic;
  
  signal tx_bit : integer range 0 to 7;
  
  type tx_state_t is (WAITING, IDLE, START, DATA, STOP);
  signal tx_state : tx_state_t; 
  
  signal char_tx : std_logic_vector(7 downto 0);
  signal char_pointer : integer range 0 to 6;
  
  signal LRC : std_logic_vector (7 downto 0);
  
  signal calcularC2_1    : std_logic;
  signal calcularC2_2   : std_logic;
  
  signal activar_lrc1 : std_logic;
  signal activar_lrc2 : std_logic;
  signal activar_lrc3 : std_logic;
  
  signal contador : std_logic;
  
  
  
begin
activar_lrc1 <= '1' when tx_state=STOP else '0'; 
activar_lrc3 <= '1' when activar_lrc1 = '1' and  activar_lrc2='0' else '0';
-----------------------------------------------------
-- Memoria ROM que almacena la trama a enviar
-----------------------------------------------------

process(clk, reset, send)
begin
  
  if (reset = '1' or send ='1') then  --cuando le doy al reset me manda 49 hex
    LRC <= x"00";
    char_tx <= conv_std_logic_vector(character'pos('I'),8);  -- hex 49
    calcularC2_1<='0';
    calcularC2_2<='0';
    activar_lrc2<='0';
    contador <= '0';
  
  elsif (clk='1' and clk'event and tx_state/=waiting and send='0') then 
      activar_lrc2 <= activar_lrc1;
      if (tx_state = STOP ) then
          case(char_pointer) is
             when 0 => --campo inicio
                char_tx <= conv_std_logic_vector(character'pos(':'),8);    --HEX 49
                  
             when 1 => --campo direccion
                char_tx <= conv_std_logic_vector(00000101, 8); --identificador del esclavo --65 en hex
                if (activar_lrc3 = '1') then
                    contador <= '0';
                elsif (contador = '0') then
                    LRC <= LRC + char_tx;
                    contador <= NOT contador;
                end if; 
                    
             when 2 => --campo funcion
                if (SignalValor = '0') then                                 --ORDEN
                    char_tx <= conv_std_logic_vector(character'pos('U'),8);   -- decimal 85  hex 55
                else 
                    char_tx <= conv_std_logic_vector(character'pos('L'),8);  -- 76 decimal   hex 4C
               end if;
               if (activar_lrc3 = '1') then
                    contador <= '0';
               elsif (contador = '0') then
                    LRC <= LRC + char_tx;
                    contador <= NOT contador;
               end if; 
              
             when 3 => --campo de datos
                char_tx <= "00000" & COLOR;      --valor del led     todos arriba hex 07
                if (activar_lrc3 = '1') then
                    contador <= '0';
                elsif (contador = '0') then
                    LRC <= LRC + char_tx;
                    contador <= NOT contador;
                    calcularC2_1 <= '1';
                end if; 
                
             when 4 =>
                char_tx <= LRC; 
             when 5 =>
                 char_tx <= conv_std_logic_vector(character'pos('F'),8); --hex 46
             when 6 =>
                 char_tx <= conv_std_logic_vector(character'pos('F'),8); --hex 46
                          
             when others =>
               char_tx <= (others=>'1');
          end case; 
  
 
          if(calcularC2_1 = '1') then
              if(calcularC2_2 = '0') THEN
                  LRC <= LRC XOR x"FF";
                  calcularC2_2 <= '1';
              elsif(calcularC2_2 = '1') THEN
                  LRC <= LRC + X"01";
                  calcularC2_1<='0';
                  calcularC2_2<='0';
              end if;
           end if;
      end if;
end if;
end process;


divisor:DivisorReloj port map 
(
    clk=>clk,
    reset=> reset,
    clk_div=>clk_div
);
  
-----------------------------------------------------
-- Maquina de estados que lee la ROM y forma la trama
-----------------------------------------------------

process(clk,reset, send, clk_div)
begin
color <= SwitchR & SwitchG & SwitchB;
SignalValor <= Switch0;
DERE2<='1';


    if (reset='1') then
        tx <= '0';
        tx_state <= waiting;
        tx_bit <= 0;
        char_pointer <= 0;
    elsif(rising_edge(clk_div)) then 
        case(tx_state) is
            when WAITING =>
                tx_bit <= 0;
                char_pointer <= 0;
                tx <= '1';
                if(send = '1') then
                    tx_state <= idle;
                end if;
          when IDLE =>  --reposo
                if(send = '0') then
                    tx <= '1';
                    tx_bit <= 0;
                    tx_state <= START;
                end if;
          when START =>     --comienzo
                if(send='0') then
                    if (char_pointer /= 0) then
                        tx <= '0';
                    end if;
                end if;
                tx_state <= DATA;
          when DATA =>      --transmitir bit a bit  
                if(send='0') then
                    if (char_pointer /= 0) then
                        tx <= char_tx(tx_bit);
                    end if;
                    if(tx_bit=7) then
                        tx_state <= STOP;
                    else
                        tx_bit <= tx_bit+1;
                    end if;
                end if;
          when STOP =>      --PARAR en este momento se ha terminado de transmitir el byte
                if(send = '0') then
                    tx <= '1';
                    if (char_pointer=6) then  --cambiar el tamaÃ±o de la trama --Hemos terminado de transmitir el mensaje
                        tx_state <= waiting;      
                    else  
                        tx_state <= idle;
                        char_pointer <= char_pointer+1;
                    end if;
                end if;       
         end case;
    end if;
end process;     
end Behavioral;
